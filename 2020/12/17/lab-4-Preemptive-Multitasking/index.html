<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lllllv.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="MIT 6.828 Lab4">
<meta property="og:type" content="article">
<meta property="og:title" content="Lab 4: Preemptive Multitasking">
<meta property="og:url" content="https://lllllv.github.io/2020/12/17/lab-4-Preemptive-Multitasking/index.html">
<meta property="og:site_name" content="Lv的杂货铺">
<meta property="og:description" content="MIT 6.828 Lab4">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lllllv.github.io/2020/12/17/lab-4-Preemptive-Multitasking/a.png">
<meta property="article:published_time" content="2020-12-17T12:05:12.000Z">
<meta property="article:modified_time" content="2021-02-27T09:44:10.951Z">
<meta property="article:author" content="lv">
<meta property="article:tag" content="MIT 6.828">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lllllv.github.io/2020/12/17/lab-4-Preemptive-Multitasking/a.png">

<link rel="canonical" href="https://lllllv.github.io/2020/12/17/lab-4-Preemptive-Multitasking/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Lab 4: Preemptive Multitasking | Lv的杂货铺</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lv的杂货铺</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">我们都是阴沟里的虫子，但总还是得有人仰望星空</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lllllv.github.io/2020/12/17/lab-4-Preemptive-Multitasking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lv">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lv的杂货铺">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Lab 4: Preemptive Multitasking
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-17 20:05:12" itemprop="dateCreated datePublished" datetime="2020-12-17T20:05:12+08:00">2020-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-27 17:44:10" itemprop="dateModified" datetime="2021-02-27T17:44:10+08:00">2021-02-27</time>
              </span>

          
            <div class="post-description">MIT 6.828 Lab4</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="Part A: Multiprocessor Support and Cooperative Multitasking"></a>Part A: Multiprocessor Support and Cooperative Multitasking</h2><p>在part A中，将要实现多处理器支持以及协同多任务处理功能。</p>
<p>在一个对称多处理器（symmetric multiprocessing, SMP）系统中，所有的核心都具有同等地位，能够访问内存和IO总线。但是在系统启动的过程中，它们还是有主次之分的，BSP（bootstrap processor）首先启动，用于进行一些设置，初始化工作，然后在操作系统启动后，BSP再将AP（application processors）唤醒。至于哪个处理器是BSP，则是由BIOS和硬件来决定的。</p>
<p>在SMP中，每一个处理器都有一个LAPIC单元，用于传递中断，同时处理器也可以读取LAPIC单元来获取这个CPU的标识符。通过LAPIC，我们可以确定当前的代码是运行在哪个CPU上的，BSP也可以唤醒某个AP令其执行某段代码；在part C中，还将要利用LAPIC来产生时钟中断以实现抢占式多任务处理。</p>
<p>LAPIC是以MMIO的方式映射到物理内存0xFE000000处的，所以需要将每个CPU的LAPIC的地址空间分别映射到虚拟地址空间的MMIOBASE～MMIOLIM处。</p>
<h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h3><p>在exercise 1中，需要完成<code>mmio_map_region()</code>函数。该函数用于将一个物理地址映射到指定的虚拟地址处。实现还是很简单的，注意MMIO虚拟地址空间不足时panic即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> len = (size % PGSIZE == <span class="number">0</span>) ? size : (size - size % PGSIZE + PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(base + len &gt; MMIOLIM)</span><br><span class="line">	panic(<span class="string">&quot;MMIO out of space!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">boot_map_region(kern_pgdir, base, len, pa, PTE_PCD|PTE_PWT|PTE_W);</span><br><span class="line"><span class="keyword">void</span>* result = (<span class="keyword">void</span>*)base;</span><br><span class="line">base += len;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>在启动AP之前，BSP会首先收集当前SMP的信息，例如AP的数量，它们的ID等等，在收集了必要的信息后，就可以着手启动AP了。现在，操作系统已经初始化完成，所以，启动AP的动作也很简单了，将一段代码复制到0x7000 (MPENTRY_PADDR)，然后BSP通过LAPIC唤醒AP执行这一段代码把AP的内部状态初始化。</p>
<h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h3><p>exercise 2要求修改之前的<code>page_init()</code>代码，避免将将物理地址0x7000 (MPENTRY_PADDR)的物理页加入free list中，以保证这片物理地址不会被虚拟内存分配掉。新的实现代码是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"></span><br><span class="line">pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// base memory</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i  &lt; MPENTRY_PADDR/PGSIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line">	pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">	pages[i].pp_link = page_free_list;</span><br><span class="line">	page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pages[i++].pp_ref = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; i &lt; npages_basemem; i++) </span><br><span class="line">&#123;</span><br><span class="line">	pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">	pages[i].pp_link = page_free_list;</span><br><span class="line">    page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="comment">// IO hole</span></span><br><span class="line"><span class="keyword">for</span>(; i &lt; EXTPHYSMEM/PGSIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line">	pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// kern &amp; kern_pgdir &amp; pages</span></span><br><span class="line"><span class="keyword">for</span>(; i &lt; ((<span class="keyword">uint32_t</span>)boot_alloc(<span class="number">0</span>)&amp;<span class="number">0x0ffffff</span>)/PGSIZE; i++)</span><br><span class="line">	pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(; i &lt; npages; i++)</span><br><span class="line">&#123;</span><br><span class="line">	pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">	pages[i].pp_link = page_free_list;</span><br><span class="line">	page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Question-1"><a href="#Question-1" class="headerlink" title="Question 1"></a>Question 1</h3><p>可以看到，AP的启动代码mpentry.S与BSP的启动代码boot.S十分相似，都是将寄存器复位，加载GDT表，修改CR0寄存器的字段开启分段，通过一个长跳转跳转进入保护模式，然后加载页目录表，开启分页，设定栈指针并通过一个间接跳转跳转到C代码。它们之间的区别就是，开始的两处地方都使用了<code>MPBOOTPHYS</code>宏来将符号的地址改变。这是因为mpentry.S是跟内核一起链接的，而内核的链接地址显然在地址空间的顶部，所以这些符号的地址并不正确，使用宏计算相对偏移并加上<code>MPENTRY_PADDR</code>这个偏移量，才是真实的物理地址，而boot.S是在boot文件夹的，它的链接地址是0x7c00，所以它就不需要使用宏来重新计算地址了。</p>
<p>在mpentry.S中，开启了分页之后，并没有一步到位加载<code>kern_pgdir</code>这个页目录表，而是先加载了最初的那个临时页表（把虚拟地址[0<del>4M),[KERNBASE</del>KERNBASE+4M)映射到物理地址[0~4M)的那个），这是因为此时的EIP还位于低地址，如果直接加载<code>kern_pgdir</code>的话，这个页表是没有相应的映射的，所以会导致错误。只有加载临时页表，然后通过间接跳转跳转到<code>mp_main()</code>（它的链接地址必然是处于高位地址的），这时EIP处于高位地址了，才能够加载<code>kern_pgdir</code>。</p>
<p>由于IDT TSS，以及各个段寄存器还未设定，而内核栈也是每个CPU分开的，所以在<code>mp_main()</code>中，需要对每个CPU进行初始化。</p>
<h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h3><p>exercise 3要求修改之前的<code>mem_init()</code>代码，为每个CPU分配一个独立的内核栈，而这些内核栈的已经通过<code>percpu_kstacks</code>给出。各个内核栈在虚拟地址空间的布局可以参考<code>memlayout.h</code>。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; NCPU; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);</span><br><span class="line">	boot_map_region(kern_pgdir, kstacktop_i - KSTKSIZE, KSTKSIZE, (<span class="keyword">uint32_t</span>)PADDR(percpu_kstacks[i]), PTE_P | PTE_W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h3><p>exercise 3要求修改之前的<code>trap_init_percpu()</code>代码，因为在SMP中，每个CPU都有自己的TSS，所以也不要再使用先前的全局符号<code>ts</code>了，而要使用<code>thiscpu-&gt;cpu_ts</code>，此外还需要为每个CPU在GDT中为其创建相应的TSS描述符，最后加载GDT和TSS到相应的寄存器，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</span><br><span class="line">thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - cpunum() * (KSTKSIZE + KSTKGAP);</span><br><span class="line">thiscpu-&gt;cpu_ts.ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</span><br><span class="line"></span><br><span class="line">gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>) &amp;(thiscpu-&gt;cpu_ts),</span><br><span class="line">				                    <span class="keyword">sizeof</span>(struct Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpunum()].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ltr(((GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpunum()) &lt;&lt; <span class="number">3</span>);</span><br><span class="line">lidt(&amp;idt_pd);</span><br></pre></td></tr></table></figure>


<p>在开始执行用户任务前，首先要解决多个CPU争用内核代码的问题。在JOS中，使用自旋锁来解决这个问题。需要添加锁操作的有两种情况：</p>
<ul>
<li><p>在AP被唤醒的过程中：AP被唤醒进行一些列初始化操作之后，在最后，会调用<code>sched_yield()</code>来请求内核调度一个用户进程并执行，这个过程自然要修改一些内核数据结构，比如<code>envs</code>数组，所以，在<code>i386_init()</code>中BSP唤醒AP之前，需要获取锁，而在AP调用<code>sched_yield()</code>前，也需要获取锁；</p>
</li>
<li><p>在AP被完全唤醒后，系统正常运行时：用户环境进入内核态后，获取锁，在离开内核态之前，归还锁。在一个锁被一个用户环境获取到之后，若同时有其他环境请求获取锁，那么对应的CPU就被阻塞在那里一直空转，直到锁被归还。</p>
</li>
</ul>
<h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><p>这个比较简单，在<code>i386_init()</code>中调用<code>boot_aps()</code>之前、<code>mp_main()</code>中调用<code>sched_yield()</code>之前分别添加<code>lock_kernel()</code>，以及在<code>trap()</code>中的开头添加：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">3</span>)</span><br><span class="line">		lock_kernel();</span><br></pre></td></tr></table></figure>

<p>另外，在<code>env_run()</code>中调用<code>env_pop_tf()</code>前添加<code>unlock_kernel()</code>即可。</p>
<h3 id="Question-2"><a href="#Question-2" class="headerlink" title="Question 2"></a>Question 2</h3><p>对于这个问题，可以考虑一下这样一种场景：CPU0在运行用户进程A，CPU1运行用户进程B。在某一时刻，进程A产生来一个异常，进行一番操作，在内核栈中构造好trapframe后跳转进内核态的<code>trap()</code>中进行异常处理，这时，进程B也产生了一个异常。尽管在对于进程A，它在进入<code>trap()</code>后便以及将外部中断屏蔽了，但是这只能管住CPU0，而CPU1依然能产生异常。虽然在<code>trap()</code>的一开头就要求首先尝试获取锁，但是回想一下异常处理过程，CPU首先从IDT表中查相应的中断处理函数入口点，然后转到内核栈，在它上面构造一个trapframe，才跳转到<code>trap()</code>。那么，如果所有CPU共享一个内核栈的话，在尝试获取锁之前，内核栈就已经被进程B的trapframe破坏掉了。这就是需要每个CPU有自己的内核栈的原因。</p>
<p>接下来实现轮询调度。<code>sched_yield()</code>的功能是寻找一个可以运行的用户环境，然后在当前的CPU上运行它；此外，还要实现一个系统调用<code>sys_yield()</code>，使得用户进程可以主动向内核交出系统资源，请求调度别的用户进程并运行。</p>
<p><code>sched_yield()</code>要添加的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!thiscpu-&gt;cpu_env)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NENV; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(envs[i].env_status == ENV_RUNNABLE)</span><br><span class="line">			env_run(&amp;envs[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> index = thiscpu-&gt;cpu_env - envs;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = (index + <span class="number">1</span>) % NENV; i % NENV != index; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(envs[i % NENV].env_status == ENV_RUNNABLE)</span><br><span class="line">			env_run(envs + i % NENV);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(envs[index].env_status == ENV_RUNNING)</span><br><span class="line">		env_run(envs + index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，在syscall.c中的<code>syscall()</code>中，在switch语句中添加<code>sys_sched()</code>的case即可。</p>
<h3 id="Question-3"><a href="#Question-3" class="headerlink" title="Question 3"></a>Question 3</h3><p>在调用了<code>lcr3()</code>之后的瞬间，尽管当前的CR3寄存器的内容已经改变，变成了另一个环境的页目录表，但是对<code>struct Env *e</code>的引用却依然是有效的，这是因为<code>e</code>指向的是内核数据结构中的<code>envs[]</code>数组中的元素，而每一个环境的页目录表对应的内核地址空间的映射都是一样的（回想一下前面的<code>env_setup_vm()</code>）。</p>
<h3 id="Question-4"><a href="#Question-4" class="headerlink" title="Question 4"></a>Question 4</h3><p>从一个环境切换到另一个环境有两种情况：</p>
<ul>
<li><p>用户进程中主动通过系统调用<code>sys_sched()</code>切换到另一个环境，而进行系统调用时，会产生一个int 48中断，并进入中断处理函数，会把此时的用户进程上下文存储在当前环境结构体的<code>struct Trapframe env_tf</code>字段，这样，以后就可以恢复寄存器状态；</p>
</li>
<li><p>当前用户进程正在运行时，外部产生了一个时钟中断，同样的，会通过trapframe将进程上下文保存在当前环境结构体的<code>struct Trapframe env_tf</code>字段。</p>
</li>
</ul>
<h3 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h3><p>exercise 6将要实现一些列系统调用，用于创建用户环境。</p>
<p>首先是<code>sys_exofork()</code>，它创建一个新的用户环境，除了寄存器状态与父进程相同外，其余都是空的，并且要求一次调用两次返回，就像Linux的<code>fork()</code>一样。其中一次调用两次返回可以通过修改新的环境结构体的<code>env_tf.tf_regs.reg_eax</code>来实现，因为在i386中，函数的返回值是装载到eax的，如果把trapframe中的eax值改为0，那么通过这个trapframe从内核态返回到用户态的时候，就相当于产生来一个返回值0了。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">new_env</span>, * <span class="title">parent_env</span>;</span></span><br><span class="line">envid2env(<span class="number">0</span>, &amp;parent_env, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">int</span> r = env_alloc(&amp;new_env, parent_env-&gt;env_id);</span><br><span class="line"><span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">new_env-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">new_env-&gt;env_tf = parent_env-&gt;env_tf;</span><br><span class="line">new_env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> new_env-&gt;env_id;</span><br></pre></td></tr></table></figure>

<p><code>sys_env_set_status()</code>、<code>sys_page_alloc()</code>、<code>sys_page_map()</code>和<code>sys_page_unmap()</code>都比较简单，相对麻烦的是参数是否有效的判断，直接放代码：</p>
<p><code>sys_env_set_status()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">env</span>;</span></span><br><span class="line"><span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line"><span class="keyword">if</span>(!(status == ENV_RUNNABLE || status == ENV_NOT_RUNNABLE))</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">env-&gt;env_status = status;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><code>sys_page_alloc()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">env</span>;</span></span><br><span class="line"><span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">		</span><br><span class="line"><span class="keyword">if</span>((<span class="keyword">uint32_t</span>)va &gt;= UTOP || (<span class="keyword">uint32_t</span>)va % PGSIZE !=<span class="number">0</span> || </span><br><span class="line">	(!(perm &amp; PTE_U)) || (!(perm &amp; PTE_P)) ||</span><br><span class="line">	(perm &amp; (~ PTE_SYSCALL)))</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">p</span> = <span class="title">page_alloc</span>(1);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!p)</span><br><span class="line">	<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> page_insert(env-&gt;env_pgdir, p, va, perm);</span><br></pre></td></tr></table></figure>

<p><code>sys_page_map()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">src_env</span>, * <span class="title">dst_env</span>;</span></span><br><span class="line"><span class="keyword">if</span>(envid2env(srcenvid, &amp;src_env, <span class="number">1</span>) &lt; <span class="number">0</span> || envid2env(dstenvid, &amp;dst_env, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span>((<span class="keyword">uint32_t</span>)srcva &gt;= UTOP || (<span class="keyword">uint32_t</span>)srcva % PGSIZE !=<span class="number">0</span> || </span><br><span class="line">	(<span class="keyword">uint32_t</span>)dstva &gt;= UTOP || (<span class="keyword">uint32_t</span>)dstva % PGSIZE !=<span class="number">0</span> || </span><br><span class="line">	!(page_lookup(src_env-&gt;env_pgdir, srcva, <span class="number">0</span>)) ||</span><br><span class="line">	(!(perm &amp; PTE_U)) || (!(perm &amp; PTE_P)) ||</span><br><span class="line">	(perm &amp; (~ PTE_SYSCALL)) ||</span><br><span class="line">	((perm &amp; PTE_W) &amp;&amp; !((*pgdir_walk(src_env-&gt;env_pgdir, srcva, <span class="number">0</span>)) &amp; PTE_W)))</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">p</span> = <span class="title">page_lookup</span>(<span class="title">src_env</span>-&gt;<span class="title">env_pgdir</span>, <span class="title">srcva</span>, 0);</span></span><br><span class="line"><span class="keyword">return</span> page_insert(dst_env-&gt;env_pgdir, p, dstva, perm);</span><br></pre></td></tr></table></figure>

<p><code>sys_page_unmap()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">env</span>;</span></span><br><span class="line"><span class="keyword">if</span>(envid2env(<span class="number">0</span>, &amp;env, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line"><span class="keyword">if</span>((<span class="keyword">uint32_t</span>)va &gt;= UTOP || (<span class="keyword">uint32_t</span>)va % PGSIZE !=<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	</span><br><span class="line">page_remove(env-&gt;env_pgdir, va);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>至此，Part A部分就完成了。</p>
<h2 id="Part-B-Copy-on-Write-Fork"><a href="#Part-B-Copy-on-Write-Fork" class="headerlink" title="Part B: Copy-on-Write Fork"></a>Part B: Copy-on-Write Fork</h2><p>part B将要实现写时复制的fork功能，首先要做的是完成用户级缺页异常处理。</p>
<p>在JOS的用户级缺页异常处理中，用户进程可以自己指定一个异常处理函数（当然这个函数也是在用户态下的），这点比较不同。整个异常处理的过程是：</p>
<ol>
<li>用户进程产生一个缺页异常，进入内核的异常处理函数；</li>
<li>内核中的异常处理函数发现异常是发生在用户态的，那么，开始着手在用户异常栈（User Exception Stack）中构造一个<code>UTrapframe</code>帧，然后根据当前环境结构体中的<code>env_pgfault_upcall</code>字段得到下一步将要跳转到的代码（<code>env_pgfault_upcall</code>指向<code>_pgfault_upcall</code>，这是一段汇编代码，用于调用用户指定的缺页处理函数，处理完缺页异常后，返回，然后，再通过一些小技巧，完美地跳回原用户进程之前执行的地方）；</li>
<li>将当前环境结构体中的trapframe的EIP，ESP分别调整为<code>env_pgfault_upcall</code>的地址以及<code>UTrapframe</code>帧的地址，然后通过<code>env_run()</code>跳转到用户级缺页异常处理代码处（此时，从内核态跳转到用户态）</li>
<li>进行缺页异常处理，并跳回原用户进程先前执行到的地方。</li>
</ol>
<h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h3><p>exercise 8要求实现一个系统调用<code>sys_env_set_pgfault_upcall()</code>，通过它，用户进程就可以自己设定自己的<code>_pgfault_upcall</code>。代码比较简单，为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">env</span>;</span></span><br><span class="line"><span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">env-&gt;env_pgfault_upcall = func;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h3><p>exercise 9要求实现<code>page_fault_handler()</code>。它在用户异常栈（User Exception Stack）中构造一个<code>UTrapframe</code>帧并跳转到<code>_pgfault_upcall</code>代码处。需要注意的地方是：</p>
<ol>
<li><p>确认用户异常栈是否满了，如果满了，自然需要panic；</p>
</li>
<li><p>可能会出现异常嵌套的情况，在处理一个缺页异常的过程中又触发了一个新的缺页异常，这时用户异常栈显然会有多个帧。此时，需要注意，<code>UTrapframe</code>帧与帧之间需要空出32bit的空间，至于为什么，后面会讲。</p>
</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(curenv-&gt;env_pgfault_upcall)</span><br><span class="line">&#123;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span>* <span class="title">base</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(UXSTACKTOP - PGSIZE &lt;= last_tf-&gt;tf_esp &amp;&amp; last_tf-&gt;tf_esp &lt;= UXSTACKTOP - <span class="number">1</span>)</span><br><span class="line">		base = (struct UTrapframe*)(last_tf-&gt;tf_esp - <span class="number">4</span> - <span class="keyword">sizeof</span>(struct UTrapframe));</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		base = (struct UTrapframe*)(UXSTACKTOP - <span class="keyword">sizeof</span>(struct UTrapframe));</span><br><span class="line"></span><br><span class="line">	user_mem_assert(curenv, base, PGSIZE, PTE_W);</span><br><span class="line"></span><br><span class="line">	base-&gt;utf_fault_va = fault_va;</span><br><span class="line">	base-&gt;utf_err = last_tf-&gt;tf_err;</span><br><span class="line">	base-&gt;utf_regs = last_tf-&gt;tf_regs;</span><br><span class="line">	base-&gt;utf_eip = last_tf-&gt;tf_eip;</span><br><span class="line">	base-&gt;utf_eflags = last_tf-&gt;tf_eflags;</span><br><span class="line">	base-&gt;utf_esp = last_tf-&gt;tf_esp;</span><br><span class="line">		</span><br><span class="line">	curenv-&gt;env_tf.tf_eip = (<span class="keyword">uint32_t</span>)curenv-&gt;env_pgfault_upcall;</span><br><span class="line">	curenv-&gt;env_tf.tf_esp = (<span class="keyword">uint32_t</span>)base;</span><br><span class="line"></span><br><span class="line">	env_run(curenv);</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">// Destroy the environment that caused the fault.</span></span><br></pre></td></tr></table></figure>

<h3 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h3><p>接下来要完成<code>_pgfault_upcall</code>的汇编代码。主要工作部分就是需要完成从这里跳转到该次缺页异常发生时的状态（通用寄存器状态、栈指针等等）。这里就要用到上面的<code>UTrapframe</code>帧与帧之间空出的32bit空间了。我们把要返回的代码段的地址（EIP应该还原成的值）放置在这里，然后再恢复各个通用寄存器的值，将esp调整为指向先前的32bit空间，最后通过一个<code>ret</code>语句，同时恢复esp和eip。代码如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">addl <span class="number">$8</span>, %esp</span><br><span class="line"><span class="keyword">mov</span> <span class="number">32</span>(%esp),%eax</span><br><span class="line"><span class="keyword">mov</span> <span class="number">40</span>(%esp),%ebx</span><br><span class="line">subl <span class="number">$4</span>, %ebx</span><br><span class="line"><span class="keyword">mov</span> %eax, (%ebx)</span><br><span class="line">subl <span class="number">$4</span>, <span class="number">40</span>(%esp) </span><br><span class="line">popal</span><br><span class="line">addl <span class="number">$4</span>, %esp </span><br><span class="line">popfl</span><br><span class="line">popl %esp</span><br><span class="line"><span class="keyword">ret</span> </span><br></pre></td></tr></table></figure>

<p>其中需要注意的是，在将eflags还原之后，就不能再使用算术操作了，否则会改变eflags的值。</p>
<h3 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11"></a>Exercise 11</h3><p>最后，需要完成<code>set_pgfault_handler()</code>。它是用于提供给用户进程的接口，用于给自己设定缺页异常的处理函数。如果是初次调用的话，会首先分配一个页作为用户异常栈。代码比较简单，为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line">r = sys_page_alloc(<span class="number">0</span>, (<span class="keyword">void</span>*)(UXSTACKTOP - PGSIZE), PTE_U | PTE_W | PTE_P);</span><br><span class="line"><span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">	panic(<span class="string">&quot;set pgfault handler error %e\n&quot;</span>, r);</span><br><span class="line">sys_env_set_pgfault_upcall(<span class="number">0</span>, _pgfault_upcall);</span><br></pre></td></tr></table></figure>

<p>接下来，将要实现写时复制的fork。写时复制技术就不再多讲了因为这是很基础的知识。</p>
<h3 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h3><p>exercise 12包含三个需要完成的函数，它们一起完成了写时分配的fork。</p>
<p>首先是<code>pgfault()</code>用于解决写时分配时的缺页异常。在一个用户环境产生了一个页故障后，首先会判断这个故障是否是因为对一个标记了写时复制的页进行写操作进行的。如果不是，则需要panic。然后，开始着手解决。它会请求分配一个新的物理页，将旧的页的内容复制到新的页，然后把旧的物理页在相应虚拟地址上的映射取消掉，将新的物理页映射到原来的虚拟地址。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(! ((err &amp; <span class="number">2</span>) &amp;&amp; ((((<span class="keyword">pte_t</span>*)UVPT)[(<span class="keyword">uint32_t</span>)addr/PGSIZE]) &amp; PTE_COW)))</span><br><span class="line">	panic(<span class="string">&quot;error in function pgfault\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span></span><br><span class="line"><span class="comment">// copy the data from the old page to the new page, then move the new</span></span><br><span class="line"><span class="comment">// page to the old page&#x27;s address.</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   You should make three system calls.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> old_page = (<span class="keyword">uint32_t</span>)addr / PGSIZE;</span><br><span class="line">sys_page_alloc(<span class="number">0</span>, PFTEMP, PTE_W | PTE_U | PTE_P);</span><br><span class="line">memmove(PFTEMP, (<span class="keyword">void</span>*)(old_page * PGSIZE), PGSIZE);</span><br><span class="line">sys_page_map(<span class="number">0</span>, PFTEMP, <span class="number">0</span>, (<span class="keyword">void</span>*)(old_page * PGSIZE), PTE_W | PTE_U | PTE_P);</span><br><span class="line">sys_page_unmap(<span class="number">0</span>, PFTEMP);</span><br></pre></td></tr></table></figure>

<p>然后是<code>duppage()</code>，该函数是在<code>fork()</code>中使用到的，它的作用是将一个环境中的一个页映射到另一个环境的相同地址，只修改页表、页目录表，而不实际复制页中的内容。在映射一个可写的页面或者标记了写时复制的页面时，它会在目标环境中也将这个页标记为写时复制，代码是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pte_t</span> src_pte = uvpt[pn];</span><br><span class="line"><span class="keyword">if</span>(src_pte)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>((src_pte &amp; PTE_W) || (src_pte &amp; PTE_COW))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>( (sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span>*)(pn * PGSIZE), envid, (<span class="keyword">void</span>*)(pn * PGSIZE), ((src_pte &amp; <span class="number">0xfff</span> &amp; ~PTE_W) | PTE_COW) &amp; PTE_SYSCALL) &lt; <span class="number">0</span>) ||</span><br><span class="line">			(sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span>*)(pn * PGSIZE), <span class="number">0</span>, (<span class="keyword">void</span>*)(pn * PGSIZE), ((src_pte &amp; <span class="number">0xfff</span> &amp; ~PTE_W) | PTE_COW) &amp; PTE_SYSCALL) &lt; <span class="number">0</span>) )</span><br><span class="line">			panic(<span class="string">&quot;duppage error on page map COW\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span>*)(pn * PGSIZE), envid, (<span class="keyword">void</span>*)(pn * PGSIZE), src_pte &amp; <span class="number">0xfff</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			panic(<span class="string">&quot;duppage error on page map\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>其中，需要注意的两点是：</p>
<ul>
<li><p>需要先映射子进程的页为COW，然后再映射父进程的页为COW。原因是，如果先映射父进程，考虑一下这种情况：在执行完第一个<code>sys_page_map()</code> 之后，在执行第二个的时候，父进程（也是当前正在执行的进程）产生了一个对这个页的写操作，那么根据处理逻辑，这个页会被替换成一个新的物理页并清除PTE_COW标记。而执行完第二个<code>sys_page_map()</code>之后，子进程的这个页被标记为PTE_COW，这产生了父子进程之间的不统一：父进程可以随意对这个页写入，而子进程并不知情！</p>
</li>
<li><p>另外，需要注意的是，虽然上面的代码中没有体现出来，但是在对子进程的页映射为PTE_COW之后，即使父进程相应的页之前也是PTE_COW，父进程也需要重新映射一遍，原因还是类似，考虑一下这种情况：如果在执行<code>sys_page_map()</code>中子进程建立相应的映射的瞬间之前，父进程产生了一个对这个页的写操作，那么根据处理逻辑，这个页会被替换成一个新的物理页并清除PTE_COW标记。同样，子进程被标记为PTE_COW而父进程没有这个标记，但是父子进程指向了相同的物理页，也产生了父子进程之间的不统一：父进程可以随意对这个页写入，而子进程不知情！</p>
</li>
</ul>
<p>最后是<code>fork()</code>。它的代码的逻辑十分清晰，就不过多解释了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">envid_t</span> envid;</span><br><span class="line"><span class="keyword">uint8_t</span> *addr;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> end[];</span><br><span class="line">set_pgfault_handler(pgfault);</span><br><span class="line"></span><br><span class="line">envid = sys_exofork();</span><br><span class="line"><span class="keyword">if</span> (envid &lt; <span class="number">0</span>)</span><br><span class="line">	panic(<span class="string">&quot;sys_exofork: %e&quot;</span>, envid);</span><br><span class="line"><span class="keyword">if</span>(envid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; USTACKTOP / PGSIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(uvpd[i / NPTENTRIES])</span><br><span class="line">		duppage(envid, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sys_page_alloc(envid, (<span class="keyword">void</span>*)(UXSTACKTOP - PGSIZE), PTE_U | PTE_P | PTE_W);</span><br><span class="line"></span><br><span class="line">sys_env_set_pgfault_upcall(envid, thisenv-&gt;env_pgfault_upcall);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; <span class="number">0</span>)</span><br><span class="line">	panic(<span class="string">&quot;sys_env_set_status: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> envid;</span><br></pre></td></tr></table></figure>

<p>至此，part B就完成了。</p>
<h2 id="Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC"><a href="#Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC" class="headerlink" title="Part C: Preemptive Multitasking and Inter-Process communication (IPC)"></a>Part C: Preemptive Multitasking and Inter-Process communication (IPC)</h2><p>part C主要的工作是两个部分：抢占式多任务处理，以及IPC。</p>
<p>在JOS中，抢占式多任务实现得比较简单，当时钟中断到来的时候，调用<code>sched_yield()</code>进行任务调度就行了。另外，在每个环境创建的时候，都要保证它是允许接收外部中断，即置eflags的FL_IF标志。</p>
<h3 id="Exercise-13"><a href="#Exercise-13" class="headerlink" title="Exercise 13"></a>Exercise 13</h3><p>这个exercise中要做的工作就是上面所说的了，比较简单</p>
<p>trapentry.S添加：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(handler32, <span class="number">32</span>)</span><br><span class="line">TRAPHANDLER_NOEC(handler33, <span class="number">33</span>)</span><br><span class="line">TRAPHANDLER_NOEC(handler34, <span class="number">34</span>)</span><br><span class="line">TRAPHANDLER_NOEC(handler35, <span class="number">35</span>)</span><br><span class="line">TRAPHANDLER_NOEC(handler36, <span class="number">36</span>)</span><br><span class="line">TRAPHANDLER_NOEC(handler37, <span class="number">37</span>)</span><br><span class="line">TRAPHANDLER_NOEC(handler38, <span class="number">38</span>)</span><br><span class="line">TRAPHANDLER_NOEC(handler39, <span class="number">39</span>)</span><br><span class="line">TRAPHANDLER_NOEC(handler40, <span class="number">40</span>)</span><br><span class="line">TRAPHANDLER_NOEC(handler41, <span class="number">41</span>)</span><br><span class="line">TRAPHANDLER_NOEC(handler42, <span class="number">42</span>)</span><br><span class="line">TRAPHANDLER_NOEC(handler43, <span class="number">43</span>)</span><br><span class="line">TRAPHANDLER_NOEC(handler44, <span class="number">44</span>)</span><br><span class="line">TRAPHANDLER_NOEC(handler45, <span class="number">45</span>)</span><br><span class="line">TRAPHANDLER_NOEC(handler46, <span class="number">46</span>)</span><br><span class="line">TRAPHANDLER_NOEC(handler47, <span class="number">47</span>)</span><br></pre></td></tr></table></figure>

<p>trap.c添加：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SETGATE(idt[<span class="number">32</span>], <span class="number">0</span>, GD_KT, &amp;handler32, <span class="number">0</span>)</span><br><span class="line">SETGATE(idt[<span class="number">33</span>], <span class="number">0</span>, GD_KT, &amp;handler33, <span class="number">0</span>)</span><br><span class="line">SETGATE(idt[<span class="number">34</span>], <span class="number">0</span>, GD_KT, &amp;handler34, <span class="number">0</span>)</span><br><span class="line">SETGATE(idt[<span class="number">35</span>], <span class="number">0</span>, GD_KT, &amp;handler35, <span class="number">0</span>)</span><br><span class="line">SETGATE(idt[<span class="number">36</span>], <span class="number">0</span>, GD_KT, &amp;handler36, <span class="number">0</span>)</span><br><span class="line">SETGATE(idt[<span class="number">37</span>], <span class="number">0</span>, GD_KT, &amp;handler37, <span class="number">0</span>)</span><br><span class="line">SETGATE(idt[<span class="number">38</span>], <span class="number">0</span>, GD_KT, &amp;handler38, <span class="number">0</span>)</span><br><span class="line">SETGATE(idt[<span class="number">39</span>], <span class="number">0</span>, GD_KT, &amp;handler39, <span class="number">0</span>)</span><br><span class="line">SETGATE(idt[<span class="number">40</span>], <span class="number">0</span>, GD_KT, &amp;handler40, <span class="number">0</span>)</span><br><span class="line">SETGATE(idt[<span class="number">41</span>], <span class="number">0</span>, GD_KT, &amp;handler41, <span class="number">0</span>)</span><br><span class="line">SETGATE(idt[<span class="number">42</span>], <span class="number">0</span>, GD_KT, &amp;handler42, <span class="number">0</span>)</span><br><span class="line">SETGATE(idt[<span class="number">43</span>], <span class="number">0</span>, GD_KT, &amp;handler43, <span class="number">0</span>)</span><br><span class="line">SETGATE(idt[<span class="number">44</span>], <span class="number">0</span>, GD_KT, &amp;handler44, <span class="number">0</span>)</span><br><span class="line">SETGATE(idt[<span class="number">45</span>], <span class="number">0</span>, GD_KT, &amp;handler45, <span class="number">0</span>)</span><br><span class="line">SETGATE(idt[<span class="number">46</span>], <span class="number">0</span>, GD_KT, &amp;handler46, <span class="number">0</span>)</span><br><span class="line">SETGATE(idt[<span class="number">47</span>], <span class="number">0</span>, GD_KT, &amp;handler47, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>然后，在env.c的<code>env_alloc()</code>中相应地方添加：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">e-&gt;env_tf.tf_eflags |= FL_IF;</span><br></pre></td></tr></table></figure>

<p>最后，不要忘记取消<code>sched_halt()</code>的<code>sti</code>那一行的注释。</p>
<h3 id="Exercise-14"><a href="#Exercise-14" class="headerlink" title="Exercise 14"></a>Exercise 14</h3><p>exercise 14要进行时钟中断的处理。在时钟中断到来的时候，进行任务调度，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// Handle clock interrupts. Don&#x27;t forget to acknowledge the</span></span><br><span class="line">	<span class="comment">// interrupt using lapic_eoi() before calling the scheduler!</span></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">if</span>(tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER)</span><br><span class="line">&#123;</span><br><span class="line">	lapic_eoi();</span><br><span class="line">	sched_yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即，如果中断号是时钟中断对应的编号的话，首先，调用<code>lapic_eoi()</code>写lapic中的eoi寄存器。在i386中，中断被处理完以后，需要向eoi寄存器通知中断已经被处理过了。接着，调用<code>sched_yield()</code>进行任务调度。</p>
<p>这个lab的最后，就是实现IPC了。IPC可以在进程间传递一个32bit的信息，以及一个可选的页面映射。需要实现两个IPC系统调用，以及两个封装这两个系统调用的库函数。</p>
<p><code>sys_ipc_recv()</code>这个系统调用用于请求接收一个IPC信息。进程调用这个函数后，会修改env结构体的相应字段表示这个进程期望收到一个IPC，并记录下希望得到的页面映射的地址，然后，将这个环境标记为<code>ENV_NOT_RUNNABLE</code>，阻塞在这里，直到收到了一个IPC为止。</p>
<p><code>sys_ipc_try_send()</code>则是向指定的进程号发送一个IPC信息，另外如果指定的进程想要收到一个页面映射，而发送方也想要发送一个页面映射，那么，就将一个页面映射传递过去，之后，发送方通过修改接收方的env结构体的字段，标记接收方不再可接收IPC信息，并将接受方进程标记为<code>ENV_RUNNABLE</code>，并重新运行被阻塞的接受方进程。</p>
<p>代码如下：</p>
<p><code>sys_ipc_recv()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((<span class="keyword">uint32_t</span>)dstva &lt; UTOP &amp;&amp; (<span class="keyword">uint32_t</span>)dstva % PGSIZE !=<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">curenv-&gt;env_ipc_recving = <span class="number">1</span>;</span><br><span class="line">curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">sched_yield();</span><br><span class="line">	</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><code>sys_ipc_try_send()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">env_recv</span>;</span></span><br><span class="line"><span class="keyword">if</span>(envid2env(envid, &amp;env_recv, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span>(!env_recv-&gt;env_ipc_recving)</span><br><span class="line">	<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((<span class="keyword">uint32_t</span>)srcva &lt; UTOP &amp;&amp; </span><br><span class="line">	((<span class="keyword">uint32_t</span>)srcva % PGSIZE !=<span class="number">0</span> ||</span><br><span class="line">	!(page_lookup(curenv-&gt;env_pgdir, srcva, <span class="number">0</span>)) ||</span><br><span class="line">	(!(perm &amp; PTE_U)) || (!(perm &amp; PTE_P)) ||</span><br><span class="line">		(perm &amp; (~ PTE_SYSCALL)) ||</span><br><span class="line">		((perm &amp; PTE_W) &amp;&amp; !((*pgdir_walk(curenv-&gt;env_pgdir, srcva, <span class="number">0</span>)) &amp; PTE_W))))</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((<span class="keyword">uint32_t</span>)srcva &lt; UTOP &amp;&amp; (<span class="keyword">uint32_t</span>)env_recv-&gt;env_ipc_dstva &lt; UTOP)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">p</span> = <span class="title">page_lookup</span>(<span class="title">curenv</span>-&gt;<span class="title">env_pgdir</span>, <span class="title">srcva</span>, 0);</span></span><br><span class="line">	<span class="keyword">int</span> r = page_insert(env_recv-&gt;env_pgdir, p, env_recv-&gt;env_ipc_dstva, perm);</span><br><span class="line">	<span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		env_recv-&gt;env_ipc_perm = perm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	env_recv-&gt;env_ipc_perm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">env_recv-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line">env_recv-&gt;env_ipc_from = sys_getenvid();</span><br><span class="line">env_recv-&gt;env_ipc_value = value;</span><br><span class="line">env_recv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">env_recv-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>另外，还有两个基于这两个系统调用的包装函数<code>ipc_send()</code>和<code>ipc_recv()</code>，这两个包装函数就比较简单了，照着注释的要求完成即可，代码如下：</p>
<p><code>ipc_send()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">while</span>((r = sys_ipc_try_send(to_env, val, (!pg) ? (<span class="keyword">void</span>*)<span class="number">0xffffffff</span> : pg, perm)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(r != -E_IPC_NOT_RECV)</span><br><span class="line">		panic(<span class="string">&quot;ipc send error %e\n&quot;</span>,r);</span><br><span class="line">	sys_yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ipc_recv()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r = sys_ipc_recv((!pg) ? (<span class="keyword">void</span>*)<span class="number">0xffffffff</span> : pg);</span><br><span class="line"><span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(from_env_store)</span><br><span class="line">		*from_env_store = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(perm_store)</span><br><span class="line">		*perm_store = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span>(from_env_store)</span><br><span class="line">	*from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(perm_store)</span><br><span class="line">	*perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br></pre></td></tr></table></figure>

<p>至此，lab4就完成了。运行一下评分脚本<br><img src="a.png" alt="img"></p>
<p><em>lab的完整代码在<a target="_blank" rel="noopener" href="https://github.com/lllllv/6.828-labs">我的GitHub</a>中可以找到</em></p>
<p>（完）</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MIT-6-828/" rel="tag"># MIT 6.828</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/11/%E6%B3%B5%E5%BC%95%E7%90%86/" rel="prev" title="泵引理">
      <i class="fa fa-chevron-left"></i> 泵引理
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/02/23/Lab-5-File-system-Spawn-and-Shell/" rel="next" title="Lab 5: File system, Spawn and Shell">
      Lab 5: File system, Spawn and Shell <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><span class="nav-number">1.</span> <span class="nav-text">Part A: Multiprocessor Support and Cooperative Multitasking</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-1"><span class="nav-number">1.1.</span> <span class="nav-text">Exercise 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-2"><span class="nav-number">1.2.</span> <span class="nav-text">Exercise 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Question-1"><span class="nav-number">1.3.</span> <span class="nav-text">Question 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-3"><span class="nav-number">1.4.</span> <span class="nav-text">Exercise 3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-4"><span class="nav-number">1.5.</span> <span class="nav-text">Exercise 4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-5"><span class="nav-number">1.6.</span> <span class="nav-text">Exercise 5</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Question-2"><span class="nav-number">1.7.</span> <span class="nav-text">Question 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Question-3"><span class="nav-number">1.8.</span> <span class="nav-text">Question 3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Question-4"><span class="nav-number">1.9.</span> <span class="nav-text">Question 4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-6"><span class="nav-number">1.10.</span> <span class="nav-text">Exercise 6</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-B-Copy-on-Write-Fork"><span class="nav-number">2.</span> <span class="nav-text">Part B: Copy-on-Write Fork</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-8"><span class="nav-number">2.1.</span> <span class="nav-text">Exercise 8</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-9"><span class="nav-number">2.2.</span> <span class="nav-text">Exercise 9</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-10"><span class="nav-number">2.3.</span> <span class="nav-text">Exercise 10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-11"><span class="nav-number">2.4.</span> <span class="nav-text">Exercise 11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-12"><span class="nav-number">2.5.</span> <span class="nav-text">Exercise 12</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC"><span class="nav-number">3.</span> <span class="nav-text">Part C: Preemptive Multitasking and Inter-Process communication (IPC)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-13"><span class="nav-number">3.1.</span> <span class="nav-text">Exercise 13</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-14"><span class="nav-number">3.2.</span> <span class="nav-text">Exercise 14</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lv</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lxy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
